const uploadFileToCloudinary = require("../utils/cloudinary");
const fs = require("fs");

const uploadImage = async (req, res) => {
  if (req.fileValidationError) {
    return res
      .status(400)
      .json({
        message: "File type not allowed",
        error: req.fileValidationError,
      });
  }

  if (!req.files || Object.keys(req.files).length === 0) {
    return res
      .status(400)
      .json({ message: "Please provide image(s) to upload." });
  }

  const imageUrls = {};
  const errors = [];

  for (const fieldName in req.files) {
    const files = req.files[fieldName];

    for (const file of files) {
      const localFilePath = file.path;
console.log("localFilePath", localFilePath)
      try {
        const cloudinaryResponse = await uploadFileToCloudinary(localFilePath);
        if (cloudinaryResponse) {
          imageUrls[fieldName] = imageUrls[fieldName] || [];
          imageUrls[fieldName].push({
            media_location: cloudinaryResponse.secure_url,
            marketplace_id: "A21TJRUUN4KGV",
          });
        } else {
          errors.push({
            field: fieldName,
            message: "Failed to upload to Cloudinary.",
          });
        }
      } catch (error) {
        console.error(`Error uploading '${fieldName}':`, error);
        errors.push({
          field: fieldName,
          message: "An error occurred during upload.",
          details: error.message,
        });
      } finally {
        // ✅ Safely delete the file only if it exists
        if (fs.existsSync(localFilePath)) {
          // fs.unlinkSync(localFilePath);
        }
      }
    }
  }

  if (errors.length > 0 && Object.keys(imageUrls).length === 0) {
    return res
      .status(500)
      .json({ message: "Failed to upload one or more images.", errors });
  }

  res
    .status(201)
    .json({ message: "Images uploaded successfully.", imageUrls, errors });
};

const singleImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded." });
    }

    // The filename generated by Multer
    const filename = req.file.filename;

    // Construct the public URL (assuming you serve from '/uploads')
    const publicImageUrl = `/uploads/${filename}`;

    res.status(200).json({ imageUrl: publicImageUrl });
  } catch (error) {
    console.error("Error uploading single image:", error);
    res.status(500).json({ message: "Failed to upload image." });
  }
};

const uploadDispatchImages = async (req, res) => {
  try {
    if (req.fileValidationError) {
      return res
        .status(400)
        .json({
          message: "File type not allowed",
          error: req.fileValidationError,
        });
    }

    if (!req.files || !req.files.dispatchImages || req.files.dispatchImages.length === 0) {
      return res
        .status(400)
        .json({ message: "Please provide dispatch image(s) to upload." });
    }

    const dispatchImageUrls = [];
    const errors = [];
    const files = req.files.dispatchImages;

    for (const file of files) {
      const localFilePath = file.path;
      console.log("localFilePath (dispatchImage):", localFilePath);

      try {
        const cloudinaryResponse = await uploadFileToCloudinary(localFilePath);
        if (cloudinaryResponse) {
          dispatchImageUrls.push({
            media_location: cloudinaryResponse.secure_url,
            marketplace_id: "A21TJRUUN4KGV", // Assuming this is still relevant
          });
        } else {
          errors.push({
            message: `Failed to upload ${file.originalname} to Cloudinary.`,
          });
        }
      } catch (error) {
        console.error(`Error uploading ${file.originalname}:`, error);
        errors.push({
          message: `An error occurred during upload of ${file.originalname}.`,
          details: error.message,
        });
      } finally {
        // ✅ Safely delete the file only if it exists
        if (fs.existsSync(localFilePath)) {
          // fs.unlinkSync(localFilePath);
        }
      }
    }

    if (errors.length > 0 && dispatchImageUrls.length === 0) {
      return res
        .status(500)
        .json({ message: "Failed to upload dispatch images.", errors });
    }

    res.status(201).json({
      message: "Dispatch images uploaded successfully.",
      imageUrls: dispatchImageUrls,
      errors,
    });
  } catch (error) {
    console.error("Error handling dispatch image upload:", error);
    res.status(500).json({ message: "Internal server error during image upload." });
  }
};
module.exports = { uploadImage, singleImage,uploadDispatchImages};
